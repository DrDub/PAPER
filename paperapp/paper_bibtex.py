import yaml
import os
import datetime
import re
import codecs

from . import PaperError

import bibtexparser
from bibtexparser.bparser import BibTexParser

def _get_parser():
    parser = BibTexParser(common_strings = True)
    return parser

def generate_bibtex(paper, _id, source=None):
    """Generate a bibtex file on stdout for the papers _id is citing."""
    start = paper.id_to_node[_id]
    all_cited_ids = set()
    print('% bibtex file generated by P.A.P.E.R.')
    print('% date: ' + datetime.datetime.now().isoformat())
    if source is None and paper._auto_save is not None:
        source = paper._auto_save
    if source is not None:
        print('% source: ' + source)
    print('% starting node: ' + _id)
    print('% generated file, remove this line if edited.\n'.upper())
        
    for relation in paper.get_nodes_by_type('relation'):
         source = relation.get('source', [])
         found = False
         if start == source:
             found = True
         elif source is list:
             for other in source:
                 if start == other:
                     found = True
         if found:
             target = relation.get('target', [])
             if not type(target) == list:
                 target = [ target ]
             for other in target:
                 all_cited_ids.add(other['id'])

    sorted_ids = list(all_cited_ids)
    sorted_ids.sort()

    for cited_id in sorted_ids:
         cited = paper.id_to_node[cited_id]
         if 'bibtex' in cited:
             b = cited['bibtex']
             print("% ", cited_id)
             print("@%s{%s" % (b['text'], b['id']))
             for k,v in b.items():
                 if not k in set(['text','id','type', 'meta']):
                     print("  , %s={%s}" % (k,v))
             print("}\n")


def import_bibtex(paper, _file, verbose=True, create_papers=False):
    """Import all bibtex entries on file. 

    Returns the IDs of the imported entries. Existing IDs are
    ignored. If create_papers is true, a paper entry will be created for
    each bibtex.
    """
    with open(_file) as f:
        db = bibtexparser.load(f, _get_parser()) # might fail
    return _process(paper, db, verbose, create_papers, _file)

def import_bibtex_str(paper, bibtex_str, verbose=True, create_papers=False):
    """Import a bibtex string. 

    Returns the IDs of the imported entries.  Existing IDs are
    ignored. If create_papers is true, a paper entry will be created for
    each bibtex and the list of returned IDs are of the papers created.
"""
    db = bibtexparser.loads(bibtex_str, _get_parser()) # might fail
    return _process(paper, db, verbose, create_papers)

def _process(paper, db, verbose=True, create_papers=False, meta=None):

    # check for suspicions "comments"
    for comment in db.comments:
      comment = comment.lower()
      if len(comment) > 0 and comment[0] == '@' and \
        not comment.startswith("@comment{") and \
        not comment.startswith("@strings{"):
        raise PaperError("Error parsing {}".format(comment))

    ids = []
    for entry in db.entries:
        _id = entry['ID']
        # normalize
        _id = list(_id)
        for idx in range(0, len(_id)):
            ch = _id[idx]
            if not ('0' <= ch <= '9' or 'A' <= ch <= 'Z' or 'a' <= ch <= 'z' or ch in '-_'):
                _id[idx] = '_'
        _id = "".join(_id)
    
        if _id in paper.id_to_node:
            if verbose:
                print('Skipping existing key %s' % (_id))
                continue
        else:
            # create the bibtex entry
            bibtex = paper.new_bibtex(_id, entry['ENTRYTYPE'], meta, entry)

            if create_papers:
                text = _id
                if 'title' in entry:
                    text = entry['title']
                if 'author' in entry:
                    text += " -- " + entry['author']
                new_paper = paper.new_paper(None, text, bibtex=bibtex)
                if verbose:
                    print("Created new paper: {}".format(new_paper['id']))
                ids.append(new_paper['id'])
            else:
                ids.append(_id)
                

    paper.auto_save()

    return ids
